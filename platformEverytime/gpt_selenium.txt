1.
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
import time

class SNSCrawler:
    def __init__(self, username, password):
        self.username = username
        self.password = password
        self.driver = self.initialize_driver()
        self.login()

    def initialize_driver(self):
        chrome_options = Options()
        chrome_options.add_argument("--headless")  # Headless 모드로 실행
        driver = webdriver.Chrome(chrome_options=chrome_options)
        return driver

    def login(self):
        self.driver.get("https://sns-platform.com/login")
        username_field = self.driver.find_element_by_id("username")
        password_field = self.driver.find_element_by_id("password")
        username_field.send_keys(self.username)
        password_field.send_keys(self.password)
        password_field.send_keys(Keys.RETURN)
        time.sleep(2)  # 로그인 후 페이지 로딩 대기

    def crawl_data(self):
        # 크롤링 로직 작성
        # 예시: self.driver.find_element_by_css_selector(".post").text
        pass

    def close_driver(self):
        self.driver.quit()

# 장고 뷰에서 사용할 함수 예시
def show_crawled_data(request):
    # 유저 정보 가져오기
    username = request.user.username
    password = request.user.password
    
    # 셀레니움을 통한 크롤링
    crawler = SNSCrawler(username, password)
    crawled_data = crawler.crawl_data()
    crawler.close_driver()

    # 크롤링 데이터를 템플릿에 전달
    return render(request, 'crawled_data.html', {'crawled_data': crawled_data})







2.
사용자가 새로고침할 때마다 새로운 세션을 만들어야하는 문제를 해결하기 위해 세션을 유지하고, 새로 고침해도 이전 상태를 유지할 수 있도록 셀레니움을 관리할 수 있습니다. 이를 위해 장고의 세션을 사용하여 사용자의 상태를 추적하고 유지하는 방법을 사용할 수 있습니다. 아래는 세션을 사용하여 상태를 유지하는 방법에 대한 예시입니다.

```python
from django.contrib.sessions.models import Session
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
import time

class SNSCrawler:
    def __init__(self, request):
        self.request = request
        self.username = self.request.user.username
        self.password = self.request.user.password
        self.driver = self.initialize_driver()
        self.login()

    def initialize_driver(self):
        chrome_options = Options()
        chrome_options.add_argument("--headless")  # Headless 모드로 실행
        driver = webdriver.Chrome(chrome_options=chrome_options)
        return driver

    def login(self):
        # 기존 세션 가져오기
        session_key = self.request.session.session_key
        session = Session.objects.get(session_key=session_key)
        if 'driver' in session:
            self.driver = session['driver']
            return
        # 새로운 세션 생성
        self.driver.get("https://sns-platform.com/login")
        username_field = self.driver.find_element_by_id("username")
        password_field = self.driver.find_element_by_id("password")
        username_field.send_keys(self.username)
        password_field.send_keys(self.password)
        password_field.send_keys(Keys.RETURN)
        time.sleep(2)  # 로그인 후 페이지 로딩 대기
        # 세션에 드라이버 저장
        session['driver'] = self.driver
        session.save()

    def crawl_data(self):
        # 크롤링 로직 작성
        # 예시: self.driver.find_element_by_css_selector(".post").text
        pass

    def close_driver(self):
        self.driver.quit()

# 장고 뷰에서 사용할 함수 예시
def show_crawled_data(request):
    # 셀레니움을 통한 크롤링
    crawler = SNSCrawler(request)
    crawled_data = crawler.crawl_data()
    crawler.close_driver()

    # 크롤링 데이터를 템플릿에 전달
    return render(request, 'crawled_data.html', {'crawled_data': crawled_data})
```

위 코드에서는 사용자의 세션을 이용하여 세션에 셀레니움 드라이버를 저장하고, 이미 세션에 드라이버가 저장되어 있는 경우에는 해당 드라이버를 사용합니다. 
이렇게 하면 사용자가 새로고침을 해도 이전에 생성한 셀레니움 드라이버를 유지할 수 있습니다.

session에 드라이버를 저장한다. (seralize 직렬화 필요) 사실상 포기.
session 에 id, password 정보 담은 다음 매번 로그인을 새로 한다.
model에 